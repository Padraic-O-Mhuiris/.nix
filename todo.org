#+title: Todo

- Host1 : laptop
- Host2 : PC
- Host3 : Remote server

- User1 : same configuration on laptop and pc
- User2 :

* Thoughts
- Higher level abstract categories of "Machines", "System", "theme", "User"
- All "System", "UI" and "User" modules are imported by default however some may be context dependent on the "category" module
- Won't be able to make it a multiuser approach I think?
- How do I selectively import modules - I want to utilise system/moduleA, system/moduleB but not system/moduleC. How is that meant to be broken out? Two options
  1) Put all modules behind a flag - system.moduleA.enable
     - I feel like this would be cluttered and would enforce doing an option wrap
       on every module definition which would be unneccessary - unless everything is wrapped by category - but that would be pointless to some extent
  2) In the host system file import those modules selectively by path
     - This is more elegant but it would mean there are no "global" modules, would have to
- It should be possible to "reproduce" every host environment on a vm machine. So for any host, it should be possible to switch it out to a vm mode - bar some networking coupling and have it operable.
- We want a high-level description of the system so there can be an accurate configuration of the system. E.g - nvidia-offload is a custom wrapper for gui intensive applications. If the user wishes to use steam games and utilise their graphics card appropriately the presumed user/steam.nix module must be able reference the machine configuration. So in the machine.nix module we should provide an enum option `machine.graphics = "nvidia"`. Assuming that and if also `hardware.nvidia.offload.enable == true`, than user/steam.nix can reliably include that configuration.
  I think a mistake can happen in some configurations where options are used for all modules and where moduleA has some configuration that requires moduleB to be enabled. Because modules can reference each other it would be a big mistake that moduleA should enable moduleB. In my eyes, there is a difference between modules as defined in nixpkgs/nixos and user defined abstracted "configuration modules" and so the path of making everyting an enable option becomes detrimental.
  The problem I feel is that the DRY method is very hard to balance and the typical breaking the system into large chunks and sometimes behind an enable option is a clunky approach. A "config-modules" should be as atomic as possible generally speaking and so selection on whether a host uses it or not is defined whether it's imported in the system/<host>/default.nix.
  Thinking more on this, the goal is to be able in one file and maybe under 100 LOC be able visualise the high-level configuration of a host. That requires careful abstraction.

- Another idea which crossed my mind is that there's a distinction and an addendum to be made of the nvidia-offload example. In that case the machine/nvidia.nix will set the machine.graphics = "nvidia". The machine.graphics option is instantiated under /modules but is best described as an "option-only" module.
  Differing from a "configuration-module" which instantiates a collection of "nixos-modules", the other type, the "option-only" module only declares state. In the graphics case, we are saying that if the machine/nvidia.nix "configuration-module" comes into scope from being imported in system/<host> (actually would be imported in machine/pc or machine/laptop), the rest of the configuration has a reference to that data. More simply, the machine/nvidia.nix provides the information that this is an nvidia based machine.
  The addendum to this is that this can go the other way in which a "configuration module" must get state passed to it in order for it to do what it's supposed to do. An example would be a system/syncthing.nix module which requires state to be defined in system/<host> in order for it to be a neutral atomic module. In the system/syncthing.nix module we can extend the system options declaration which would be `options.os.system.syncthing`
- If we do everything this way then it might not be necessary to even create "option-only" modules. We can just specify the module definitions in `machines/nvidia.nix` as `options.os.machines.gpu = "nvidia"`. The problem is that would break something else because we define usage of "nvidia" as the machine gpu by importing that module and so if we were to do it as intended, both the intel and nvidia configuration sets would have to specified and conditionally evaluate the module. However that module would have to be always included. This breaks our rule of no global modules (obfuscation) and of coupling different logic (atomicity).
- Networking could be part of system but as these systems are meant to inter-connect with ssh/gpg/syncthing/ngrok/tailscale/wireguard/firewall it might be best to manage in it's own domain.
- Actually networking can be a sub-system category probably
- User and theme are complicated but I think for the most part can seen as their own thing. Maybe that can be generalized to "preferences" or some other word.
  The takeaway is that user corresponds to configuration such as the shell environment or whether emacs or vim is the default editor. Theme (undecided name, maybe UI) is really about look and feel - what wallpaper, font, etc. Some of this functionality may have to be lifted to abstract state so that other modules can inject this state appropriately. As of writing though theme/ui is gnarly enough and should be kept simple for the most part. Would be nice to do simple things like switch between Xserver and wayland

* Structure

#+begin_src
.
|-- machines
|   |-- laptop
|   |   |-- default.nix <|Imported in /system/<host>/default.nix
|   |   `-- *.nix
|   |-- pc
|   |   |-- default.nix
|   |   `-- *.nix
|   |-- aws
|   |   |-- default.nix
|   |   `-- *.nix
|   |-- vm
|   |   |-- default.nix
|   |   `-- *.nix
|   `-- nvidia.nix <|abstracted configuration shared between multiple machines
|-- system
|   |
|   `-- *
|-- networking
|   |
|   `-- *
|-- user
|   |
|   `-- *
`-- theme
    |
    `-- *


#+end_src

* Machines
- Every machine is 1:1 with a "host" generally speaking so we can expect to create a unique per host file which defines a system configuration which will produce a minimal "bootable" base layer.

- Generalising at this layer is arguably the easiest as it does not depend on the other categories of the configuration. However there are some options which could have upward dependency on for instance boot menu theming

- Also this level is not constrained to define only "real" hardware. I can envisage definitions for remote deployments - aws/digital-ocean etc and also for varying vm types.
  The point is that these ought to provide a target layer for more configuration on top of it

- It's loosely coupled from the rest of the definitions

- One module to think of is a "machine" module which may define configuration for

- Should be named on the basis of the machine rather than the host. So "laptop" or "dellXps9520"

* System
- A system is the collection of modules which defines the cross-user functionality. Things like networking/firewall/security/time definitions are specified here.
- Way to think about modules categorised here is if the system targeted a multiuser definition what software would need to be installed
- The configuration of system-level modules would be pretty common across hosts generally
- configuration for all modules should reside here
- option should specify whether the host is a desktop or server
